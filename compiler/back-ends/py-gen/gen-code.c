/*
 * compiler/back-ends/py-gen/gen-code.c - routines for printing python
 *                                        code from type trees
 *
 * assumes that the type tree has already been run through the
 * python type generator (py-gen/types.c).
 *
 * Copyright (C) 2016 Aaron Conole
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 */
#include "config.h"
#include "snacc.h"

#if TIME_WITH_SYS_TIME
# include <sys/time.h>
# include <time.h>
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>
# else
#  include <time.h>
# endif
#endif

#include <string.h>

#include "asn-incl.h"
#include "asn1module.h"
#include "rules.h"
#include "snacc-util.h"
#include "print.h"
#include "tag-util.h"  /* get GetTags/FreeTags/CountTags/TagByteLen */

#if META
#include "meta.h"
#endif


enum BasicTypeChoiceId ParanoidGetBuiltinType PARAMS ((t),Type *t);
void PrintPyAnyCode PROTO ((FILE *src, FILE *hdr, PyRules *r,
							ModuleList *mods, Module *m));
void PrintPyValueDef PROTO ((FILE *src, PyRules *r, ValueDef *v));
void PrintPyValueExtern PROTO ((FILE *hdr, PyRules *r, ValueDef *v));
static char *
LookupNamespace PROTO ((Type *t, ModuleList *mods));

/* flag to see if constraints were present */
static int constraints_flag;
static long lconstraintvar=0;

extern char *bVDAGlobalDLLExport;
extern int gNO_NAMESPACE;
extern const char *gAlternateNamespaceString;
extern int genPERCode;
//extern short ImportedFilesG;

static const char bufTypeNameG[] = "asn_buffer.AsnBuf";
static const char lenTypeNameG[] = "AsnLen";
static const char tagTypeNameG[] = "AsnTag";
static const char baseClassesG[] = "(asn_base.AsnBase)";

static int printTypesG;
static int printEncodersG;
static int printDecodersG;
static int printPrintersG;
static int printFreeG;

static char *GetImportFileName (char *Impname, ModuleList *mods)
{
    Module *currMod;
    char *fileName = NULL;
    FOR_EACH_LIST_ELMT (currMod, mods) {
        /* Find the import Module in the Modules and
         * return the header file name
         */
        if ((strcmp(Impname, currMod->modId->name) == 0)) {
            /* Set the file name and break */
            fileName = currMod->cxxHdrFileName;
            break;
        }
    }
    return fileName;
}

static Module *GetImportModuleRef (char *Impname, ModuleList *mods)
{
    Module *currMod=NULL;
    FOR_EACH_LIST_ELMT (currMod, mods) {
        /* Find the import Module in the Modules and
         * return the header file name
         */
        if ((strcmp(Impname, currMod->modId->name) == 0)) {
            break;
        }
    }
    return currMod;
}

/* Prints the default instantiation for a typedefined object */
static void PrintPyTypeDefDefault PARAMS((src, td),
                                         FILE* src _AND_
                                         TypeDef* td)
{
    fprintf(src,
            "%s=%s\n\n",

            td->cxxTypeDefInfo->className ?
            td->cxxTypeDefInfo->className :
            "ERROR__",

            td->type->cxxTypeRefInfo->className ?
            td->type->cxxTypeRefInfo->className :
            "BAD__");
}


static void
PrintSrcComment PARAMS ((src, m),
    FILE *src _AND_
    Module *m)
{
    time_t now = time (NULL);

    fprintf (src, "# %s - class definitions for ASN.1 module %s\n",
             m->cxxSrcFileName, m->modId->name);
    fprintf (src, "#\n");
    fprintf (src, "#   This file was generated by esnacc on %s\n",
             ctime(&now));
    fprintf (src, "#   NOTE: this is a machine generated file-"
             "-editing not recommended\n");
    fprintf (src, "\n");

} /* PrintSrcComment */


static void
PrintSrcIncludes PARAMS ((src), FILE *src)
{
    fprintf(src, "from esnacc import asn_base\n");
    fprintf(src, "from esnacc import asn_bool\n");
    fprintf(src, "from esnacc import asn_buffer\n");
    fprintf(src, "from esnacc import asn_ints\n");
    fprintf(src, "from esnacc import asn_list\n");
    fprintf(src, "from esnacc import asn_octs\n");
    fprintf(src, "from esnacc import asn_useful\n");
    /* TODO: import modules */
    fprintf(src, "\n");
} /* PrintSrcIncludes */

/*
 * prints inline definition of constructors if this class is
 * derived from a library class.
 * assumes FILE *f is positioned in the derived class definition (.h)
 *
 * 12/92 MS - added overloaded "=" ops for string types.
 */
static void
PrintDerivedConstructors PARAMS ((f, td),
    FILE *f _AND_
    TypeDef *td)
{
    char *baseClassName = td->type->cxxTypeRefInfo->className;
    fprintf(f,
            "    def __init__(self, value=None):\n"
            "        %s.__init__(self,value)\n\n", baseClassName);
}

/*
 * prints length encoding code.  Primitives always use
 * definite length and constructors get "ConsLen"
 * which can be configured at compile to to be indefinite
 * or definite.  Primitives can also be "short" (isShort is true)
 * in which case a fast macro is used to write the length.
 * Types for which isShort apply are: boolean, null and
 * (almost always) integer and reals
 */
static void
PrintPyLenEncodingCode PARAMS ((f, lenVarName, bufVarName, classStr,
                                formStr),
                               FILE *f _AND_
                               char *lenVarName _AND_
                               char *bufVarName _AND_
                               char *classStr _AND_
                               char *formStr)
{
    fprintf(f, "        %s += asn_buffer.BEncDefLen(%s, %s)\n",
            lenVarName, bufVarName, lenVarName);
    fprintf(f, "        TAG_CODE = asn_base.BERConsts.MakeTag(asn_base.BERConsts.%s,\n"
             "                                              self.%s,\n"
             "                                              self.BER_TAG)\n",
             classStr, formStr);
}

/* prints last tag's encoding code first */
static void
PrintPyTagAndLenList PARAMS ((src, tagList, lenVarName, bufVarName),
    FILE *src _AND_
    TagList *tagList _AND_
    char *lenVarName _AND_
    char *bufVarName)
{
    char *classStr;
    char *formStr;
    Tag *tg;
    int tagLen;

    if ((tagList == NULL) || LIST_EMPTY (tagList))
        return;

    /*
     * since encoding backward encode tags backwards
     */
    FOR_EACH_LIST_ELMT_RVS (tg, tagList) {
        classStr = Class2ClassStr (tg->tclass);

        if (tg->form == CONS) {
            formStr = Form2FormStr (CONS);
        } else {
            formStr = Form2FormStr (PRIM);
        }
        PrintPyLenEncodingCode (src, lenVarName, bufVarName,
                                classStr, formStr);
        fprintf (src, "\n");

        if (tg->tclass == UNIV) {
            const char* ptr = DetermineCode(tg, &tagLen, 0);
            fprintf (src, "    %s += BEncTag%d (%s, %s, %s, %s);\n", lenVarName, tagLen, bufVarName, classStr, formStr, ptr);
        } else {
            const char* ptr = DetermineCode(tg, &tagLen, 1);
            fprintf(src, "    %s += BEncTag%d(%s, %s, %s, %s);\n", lenVarName, tagLen, bufVarName, classStr, formStr, ptr);
        }                                                       //RWC;tg->code);
    }
} /* PrintPyTagAndLenList */

/*
 *  Recursively walks through tags, printing lower lvl tags
 *  first (since encoding is done backwards).
 *
 */
static void
PrintPyTagAndLenEncodingCode PARAMS ((src, t, lenVarName, bufVarName),
    FILE *src _AND_
    Type *t _AND_
    char *lenVarName _AND_
    char *bufVarName)
{
    TagList *tl;
    int stoleChoiceTags;

    /*
     * get all the tags on this type
     */
    tl = (TagList*) GetTags(t, &stoleChoiceTags);

    /*
     * leave choice elmt tag enc to encoding routine
     */
    if (!stoleChoiceTags)
        PrintPyTagAndLenList(src, tl, lenVarName, bufVarName);

    FreeTags(tl);
} /* PrintPyTagAndLenEncodingCode */


/*
 * returns true if elmts curr following
 *  onward are all optional ow. false
 */
static int
RestAreTailOptional PARAMS ((e),
    NamedTypeList *e)
{
    NamedType *elmt;
    void *tmp;
    int retVal;

    if (e == NULL)
        return TRUE;

    tmp = (void*)CURR_LIST_NODE (e);
    retVal = TRUE;
    AsnListNext (e);
    FOR_REST_LIST_ELMT (elmt, e)
    {
        if ((!elmt->type->optional) && (elmt->type->defaultVal == NULL)&&(!elmt->type->extensionAddition))
        {
            retVal = FALSE;
            break;
        }
    }
    SET_CURR_LIST_NODE (e, tmp); /* reset list to orig loc */
    return retVal;
}


/*
 * prints typedef or new class given an ASN.1  type def of a primitive type
 * or typeref.  Uses inheritance to cover re-tagging and named elmts.
 */
static void
PrintPySimpleDef PARAMS ((src, td),
                         FILE *src _AND_
                         TypeDef *td)
{
    Tag *tag;
    TagList *tags;
    char *formStr;
    char *classStr;
    CNamedElmt *n;
    int stoleChoiceTags;

    if (IsNewType (td->type)) {
        int	hasNamedElmts;

        fprintf(src, "class %s(%s):\n",
                td->cxxTypeDefInfo->className,
                td->type->cxxTypeRefInfo->className);

        if ((hasNamedElmts = HasNamedElmts (td->type)) != 0) {
            int count = 0;
            fprintf(src, "    # ENUMERATIONS\n");
            FOR_EACH_LIST_ELMT (n, td->type->cxxTypeRefInfo->namedElmts) {
                fprintf(src, "    %s = %d\n", n->name, n->value);
                count++;
            }
            fprintf(src, "\n");
        }

        /*
         * must explicitly call constructors for base class
         */
        PrintDerivedConstructors (src, td);

        fprintf(src, "    def typename(self):\n");
        fprintf(src, "        return \"%s\"\n\n",
                td->cxxTypeDefInfo->className);
        /*
         * Re-do BerEncode, BerDeocode, BerDecodePdu and BerDecodePdu
         * if this type has been re-tagged
         */
        if ((IsDefinedByLibraryType(td->type) && !HasDefaultTag(td->type))
            || (IsTypeRef (td->type) && ((td->type->tags != NULL)
                                         && !LIST_EMPTY(td->type->tags)))) {

            int tagLen = 0;
            tags = GetTags (td->type, &stoleChoiceTags);
            if (tags->count > 1) {
                fprintf(src, "    # WARNING: only one tag added...\n");
            }
            tag = tags->first->data;
            classStr = Class2ClassStr (tag->tclass);
            formStr = Form2FormStr((tag->form == ANY_FORM) ? PRIM : tag->form);
            fprintf(src, "    BER_FORM = asn_base.BERConsts.%s\n", formStr);
            fprintf(src, "    BER_CLASS = asn_base.BERConsts.%s\n", classStr);
            fflush(src);
            if (!stoleChoiceTags) {
                const char *ptr = DetermineCode(tag, &tagLen, (tag->tclass == UNIV) ? 0 : 1);
                fprintf(src, "    BER_TAG = %s\n", ptr);
            }
            FreeTags(tags);
            fprintf(src, "\n\n");
        }
    } else {
        /* For now, we don't handle constrained values in primitive types */
        PrintPyTypeDefDefault(src, td);
    }
}

static void
PrintPyChoiceDefCode(FILE *src, FILE *hdr, ModuleList *mods, Module *m,
                     PyRules *r, TypeDef *td,Type *parent, Type *choice,
                     int novolatilefuncs)
{
    fprintf(src, "# WARNING : Choice code not implemented.\n");
    fprintf(src, "# This ASN.1 file will not load properly.\n");
}

static char *
PyDetermineCode(Tag *tag, int *ptagLen, int bJustIntegerFlag)
{
    static char retstring[256];
    char *codeStr=NULL;
    int iValue=500;
    memset(retstring, 0, sizeof(retstring));
    if (tag->valueRef == NULL) {
        if (!bJustIntegerFlag) {
            char *univstr = Code2UnivCodeStr(tag->code);
            sprintf(retstring, "asn_base.BERConsts.%s", univstr);
        } else {
            sprintf(retstring, "%d", tag->code);
        }
        codeStr = retstring;
        if (ptagLen) {
            *ptagLen = TagByteLen(tag->code);
        }
    } else {
        if (tag->valueRef && tag->valueRef->basicValue &&
            tag->valueRef->basicValue->choiceId == BASICVALUE_LOCALVALUEREF &&
            tag->valueRef->basicValue->a.localValueRef &&
            tag->valueRef->basicValue->a.localValueRef->link &&
            tag->valueRef->basicValue->a.localValueRef->link->value &&
            tag->valueRef->basicValue->a.localValueRef->link->value->basicValue) {
            if (tag->valueRef->basicValue->a.localValueRef->link->value->basicValue->choiceId ==
                BASICVALUE_INTEGER) {
                iValue = tag->valueRef->basicValue->a.localValueRef->link->
                    value->basicValue->a.integer;
            } else if (tag->valueRef->basicValue->a.localValueRef->link->value->basicValue->choiceId ==
                       BASICVALUE_LOCALVALUEREF) {
                ValueRef *pvalueRef = NULL;
                if (tag->valueRef->basicValue->a.localValueRef->link->value->basicValue->choiceId == BASICVALUE_LOCALVALUEREF) {
                    pvalueRef = tag->valueRef->basicValue->a.localValueRef->link->value->basicValue->a.localValueRef;
                    if (pvalueRef->link->value && pvalueRef->link->value->basicValue &&
                        pvalueRef->link->value->basicValue->choiceId == BASICVALUE_INTEGER)
                        iValue = pvalueRef->link->value->basicValue->a.integer;
                }
            } else {
                printf("Tag value type NOT RECOGNIZED; COULD NOT RESOLVE tag integer!\n");
            }
        } else if (tag->valueRef->basicValue->choiceId ==
                   BASICVALUE_IMPORTVALUEREF &&
                   tag->valueRef->basicValue->a.importValueRef &&
                   tag->valueRef->basicValue->a.importValueRef->link &&
                   tag->valueRef->basicValue->a.importValueRef->link->value &&
                   tag->valueRef->basicValue->a.importValueRef->link->value->
                   basicValue &&
                   tag->valueRef->basicValue->a.importValueRef->link->value->
                   basicValue->choiceId == BASICVALUE_INTEGER) {
            iValue = tag->valueRef->basicValue->a.importValueRef->link->
                value->basicValue->a.integer;
        }
        sprintf(retstring, "%d", iValue);
        codeStr = retstring;
        if (ptagLen) {
            *ptagLen = TagByteLen(iValue);
        }
    }
    return(codeStr);
}

static void
PrintPySeqOrSetDefCode(FILE *src,
                       FILE *hdr ESNACC_UNUSED,
                       ModuleList *mods ESNACC_UNUSED,
                       Module *m ESNACC_UNUSED,
                       PyRules *r ESNACC_UNUSED,
                       TypeDef *td,
                       Type *parent ESNACC_UNUSED,
                       Type *seq, int novolatilefuncs ESNACC_UNUSED,
                       int isSequence)
{
    NamedType *e;
    char *classStr;
    char *codeStr;
    Tag *tag;

    fprintf(src, "class %s%s:\n\n", td->cxxTypeDefInfo->className,
            baseClassesG);

    tag = seq->tags->first->data;
    classStr = Class2ClassStr (tag->tclass);
    codeStr = PyDetermineCode(tag, NULL, (tag->tclass == UNIV) ? 0 : 1);
    fprintf(src, "    BER_CLASS=asn_base.BERConsts.%s\n", classStr);
    fprintf(src, "    BER_FORM=asn_base.BERConsts.BER_CONSTRUCTED_FORM\n\n");
    fprintf(src, "    BER_TAG=%s\n", codeStr);
    /* write out the sequence elmts */

    if (!seq->basicType->a.sequence || !seq->basicType->a.sequence->count) {
        fprintf(stderr, "WARNING: Sequence unknown?\n");
    }

    fprintf(src, "    def typename(self):\n");
    fprintf(src, "        return \"%s\"\n\n", td->cxxTypeDefInfo->className);
    /* constructor */
    fprintf(src, "    def __init__(self");
    FOR_EACH_LIST_ELMT(e, seq->basicType->a.sequence) {
        if (e->type->extensionAddition)
            continue;

        fprintf(src, ", %s", e->type->cxxTypeRefInfo->fieldName);

        if (e->type->defaultVal) {
            Value *defVal = GetValue(e->type->defaultVal->value);
            switch (ParanoidGetBuiltinType(e->type)) {
            case BASICTYPE_INTEGER:
            case BASICTYPE_ENUMERATED:
                fprintf(src, " = %s(%d)",
                        e->type->cxxTypeRefInfo->className,
                        defVal->basicValue->a.integer);
                break;
            case BASICTYPE_BOOLEAN:
                fprintf(src, " = asn_bool.AsnBool(%s)",
                        defVal->basicValue->a.boolean == 0 ?
                        "\"False\"" : "\"True\"");
                break;
            case BASICTYPE_BITSTRING:
                fprintf(stderr,
                        "WARNING: unsupported default BIT STRING\n");
                break;
            default:
                fprintf(src, " = %s()\n",
                        e->type->cxxTypeRefInfo->className);
                break;
            } /* end switch */
        } else {
            fprintf(src, " = None");
        }
    }
    fprintf(src, "):\n");

    FOR_EACH_LIST_ELMT(e, seq->basicType->a.sequence) {
        if (e->type->extensionAddition)
            continue;

        fprintf(src, "        if ");
        fprintf(src, "%s is not None and ",
                    e->type->cxxTypeRefInfo->fieldName);
        fprintf(src, "not isinstance(%s, %s):\n",
                e->type->cxxTypeRefInfo->fieldName,
                e->type->cxxTypeRefInfo->className);
        fprintf(src, "            raise TypeError(\"Expected %s for %s\")\n",
                e->type->cxxTypeRefInfo->className,
                e->type->cxxTypeRefInfo->fieldName);
        fprintf(src, "        else:\n");
        fprintf(src, "            self.%s = %s\n",
                e->type->cxxTypeRefInfo->fieldName,
                e->type->cxxTypeRefInfo->fieldName);
    }

    fprintf(src, "\n\n");

    /* benccontent */
    fprintf(src, "    def BEncContent(self, asnbuf):\n");
    fprintf(src, "        asnlen = 0\n");
    FOR_EACH_LIST_ELMT(e, seq->basicType->a.sequence) {
        if (e->type->extensionAddition)
            continue;

        fprintf(src, "        ");
        char *indent = "        ";
        if (e->type->cxxTypeRefInfo->isPtr) {
            fprintf(src, "if self.%s is not None:\n",
                    e->type->cxxTypeRefInfo->fieldName);
            indent = "            ";
        } else {
            fprintf(src, "if self.%s is None:\n            "
                    "raise UnboundLocalError('Populate %s before encoding')\n",
                    e->type->cxxTypeRefInfo->fieldName,
                    e->type->cxxTypeRefInfo->fieldName);
        }
        if (e->type->tags->count) {
            fprintf(src, "%s# %d tags to encode\n", indent,
                    e->type->tags->count);
            fprintf(src, "%ssafe_buf = asnbuf\n", indent);
            fprintf(src, "%ssafe_len = asnlen\n", indent);
            fprintf(src, "%sasnlen = 0\n", indent);
            fprintf(src, "%sasnbuf = %s()\n", indent, bufTypeNameG);
        }
        fprintf(src, "%sasnlen += self.%s.BEnc(asnbuf)\n", indent,
                e->type->cxxTypeRefInfo->fieldName);
        /* this will only be entered if the above check for count is true */
        FOR_EACH_LIST_ELMT(tag, e->type->tags) {
            fprintf(src, "%snewbuf = %s()\n", indent, bufTypeNameG);
            fprintf(src, "%stagCode = asn_base.BERConsts.MakeTag(asn_base.BERConsts.%s, asn_base.BERConsts.%s, %d)\n",
                    indent, Class2ClassStr(tag->tclass),
                    Form2FormStr(tag->form), tag->code);
            fprintf(src, "%sasnlen += asn_buffer.BEncDefLen(asnbuf, asnlen)\n",
                    indent);
            fprintf(src, "%sasnlen += asnbuf.PutBufReverse(tagCode)\n",
                    indent);
            fprintf(src, "%snewbuf.PutBuf(asnbuf.buf)\n", indent);
            fprintf(src, "%sasnbuf = newbuf\n", indent);
        }
        if (e->type->tags->count) {
            fprintf(src, "%ssafe_buf.PutBuf(asnbuf.buf)\n", indent);
            fprintf(src, "%sasnbuf = safe_buf\n", indent);
            fprintf(src, "%sasnlen = asnlen + safe_len\n", indent);
        }
    }
    fprintf(src, "        return asnlen\n\n");

    /* bdeccontent */
    fprintf(src, "    def BDecContent(self, asnbuf, length):\n");
    fprintf(src, "        asnlen = 0\n");
    FOR_EACH_LIST_ELMT(e, seq->basicType->a.sequence) {
        if (e->type->extensionAddition)
            continue;

        int i = 0;
        Tag *lastTag = NULL;
        fprintf(src, "        # tags: %d\n", e->type->tags->count);
        FOR_EACH_LIST_ELMT(tag, e->type->tags) {
            char *formStr = Form2FormStr(tag->form);
            lastTag = tag;
            if (i) {
                fprintf(src, "        bufTag, al = self.BDecTag(asnbuf, asnlen)\n");
                fprintf(src, "        if bufTag != TAG_CODE_EXPECTED:\n");
                fprintf(src, "            raise Exception('ahh: %%x vs %%x' %% (bufTag, TAG_CODE_EXPECTED))\n");
                fprintf(src, "        asnlen += al\n"
                             "        asnbuf.swallow(al)\n");
                fprintf(src, "        tagTotalLen, totalBytesLen = asn_buffer.BDecDefLen(asnbuf)\n");
                fprintf(src, "        asnlen += tagTotalLen\n");
            } else {
                i = 1;
            }
            if (tag->tclass == CNTX)
                formStr = Form2FormStr(CONS);
            fprintf(src,
                    "        TAG_CODE_EXPECTED = asn_base.BERConsts.MakeTag(asn_base.BERConsts.%s, asn_base.BERConsts.%s, %d)\n",
                    Class2ClassStr(tag->tclass), formStr, tag->code);
        }
        if (!e->type->tags->count) {
            fprintf(src,
                    "        TAG_CODE_EXPECTED = asn_base.BERConsts.MakeTag(%s.BER_CLASS,\n"
                    "                                              %s.BER_FORM,\n"
                    "                                              %s.BER_TAG)\n",
                    e->type->cxxTypeRefInfo->className,
                    e->type->cxxTypeRefInfo->className,
                    e->type->cxxTypeRefInfo->className);
        }
        fprintf(src, "        bufTag, al = self.BDecTag(asnbuf, asnlen)\n");
        fprintf(src, "        if bufTag != TAG_CODE_EXPECTED:\n");
        if (!e->type->cxxTypeRefInfo->isPtr)
            fprintf(src, "            raise Exception('Unexpected: %%x; expected: %%x' %% (bufTag, TAG_CODE_EXPECTED))\n");
        else
            fprintf(src, "            pass\n");
        fprintf(src, "        else:\n");
        if (e->type->tags->count == 1 && lastTag && lastTag->tclass == CNTX) {
            fprintf(src, "            asnbuf.swallow(al)\n");
            fprintf(src, "            tagTotalLen, totalBytesLen = asn_buffer.BDecDefLen(asnbuf)\n");
            fprintf(src, "            asnlen += tagTotalLen\n");
        }
        fprintf(src, "            self.%s = %s()\n",
                e->type->cxxTypeRefInfo->fieldName,
                e->type->cxxTypeRefInfo->className);
        fprintf(src, "            asnlen += self.%s.BDec(asnbuf, length)\n",
                e->type->cxxTypeRefInfo->fieldName);
    }
    fprintf(src, "        return asnlen\n\n");

    fprintf(src, "    def __str__(self):\n");
    fprintf(src, "        s = \"%%s = {\" %% self.typename()\n");
    FOR_EACH_LIST_ELMT(e, seq->basicType->a.sequence) {
        fprintf(src, "        s += \"%s = \"\n",
                e->type->cxxTypeRefInfo->fieldName);
        fprintf(src, "        if self.%s is not None:\n",
                e->type->cxxTypeRefInfo->fieldName);
        fprintf(src, "            s += str(self.%s)\n",
                e->type->cxxTypeRefInfo->fieldName);
        fprintf(src, "        else:\n");
        fprintf(src, "            s += \"None\"\n");
        fprintf(src, "        s += \"\\n\"\n");
    }
    fprintf(src, "        s += \"}\"\n");
    fprintf(src, "        return s;\n");
}


static void
PrintPySeqDefCode (FILE *src, FILE *hdr, ModuleList *mods, Module *m,
                    PyRules *r ,TypeDef *td, Type *parent ESNACC_UNUSED,
                    Type *seq, int novolatilefuncs ESNACC_UNUSED)
{

    PrintPySeqOrSetDefCode (src, hdr, mods, m, r, td, parent, seq,
                            novolatilefuncs, 1);

} /* PrintPySeqDefCode */


static void
PrintPySetDefCode (FILE *src, FILE *hdr, ModuleList *mods, Module *m,
                    PyRules *r, TypeDef *td, Type *parent ESNACC_UNUSED,
                    Type *set, int novolatilefuncs ESNACC_UNUSED)
{
    PrintPySeqOrSetDefCode (src, hdr, mods, m, r, td, parent, set,
                            novolatilefuncs, 0);

} /* PrintPySetDefCode */


static void
PrintPyListClass(FILE *src, TypeDef *td, Type *lst, Module* m)
{
   struct NamedType p_etemp;
   NamedType* p_e;
   char *lcn; /* list class name */
   char *ecn; /* (list) elmt class name */

   p_e = &p_etemp;
   p_e->type = lst->basicType->a.setOf;

   ecn = lst->basicType->a.setOf->cxxTypeRefInfo->className;
   lcn = td->cxxTypeDefInfo->className;

   fprintf(src, "class %s(asn_list.", lcn);

   switch (lst->basicType->choiceId) {
   case BASICTYPE_SEQUENCEOF:
       fprintf(src, "AsnSequenceOf");
	    break;
   case BASICTYPE_SETOF:
       fprintf(src, "AsnSetOf");
       break;

   default:
       break;
   }

   fprintf(src, "):\n");
   fprintf(src, "    def __init__(self, elemts=None, expected=None):\n");
   fprintf(src, "        if expected is None:\n");
   fprintf(src, "            expected = %s\n", ecn);
   fprintf(src, "        asn_list.%s.__init__(self, elemts, expected)\n\n",
           (lst->basicType->choiceId == BASICTYPE_SEQUENCEOF) ?
           "AsnSequenceOf" : "AsnSetOf");

   fprintf(src, "    def typename(self):\n");
   fprintf(src, "        return \"%s\"\n\n", lcn);

   if (td->type->subtypes != NULL) {
       if ((td->type->subtypes->choiceId == SUBTYPE_SINGLE) &&
           (td->type->subtypes->a.single->choiceId ==
            SUBTYPEVALUE_SIZECONSTRAINT) &&
           (td->type->subtypes->a.single->a.sizeConstraint->choiceId ==
            SUBTYPE_SINGLE)) {
#if 0
			PrintPySetOfSizeConstraint(src,
				td->type->subtypes->a.single->a.sizeConstraint->a.single,
				m, td->type);
#endif
       } else {
           PrintErrLoc(m->asn1SrcFileName, (long)td->type->lineNo);
           fprintf(errFileG, "ERROR - unsupported constraint\n");
       }
   }
}

static void
PrintPySetOfDefCode PARAMS ((src, m, td, setOf),
    FILE *src _AND_
    Module *m _AND_
    TypeDef *td _AND_
    Type *setOf)
{
    /* do class */
	PrintPyListClass(src, td, setOf, m);

} /* PrintPySetOfDefCode */


static void
PrintPyTypeDefCode PARAMS ((src, hdr, mods, m, r, td, novolatilefuncs),
                           FILE *src _AND_
                           FILE *hdr _AND_
                           ModuleList *mods _AND_
                           Module *m _AND_
                           PyRules *r _AND_
                           TypeDef *td _AND_
                           int novolatilefuncs)
{
    switch (td->type->basicType->choiceId) {
    case BASICTYPE_BOOLEAN:  /* library type */
    case BASICTYPE_REAL:  /* library type */
    case BASICTYPE_OCTETSTRING:  /* library type */
    case BASICTYPE_NULL:  /* library type */
    case BASICTYPE_EXTERNAL:		/* library type */
    case BASICTYPE_OID:  /* library type */
    case BASICTYPE_RELATIVE_OID:
    case BASICTYPE_INTEGER:  /* library type */
    case BASICTYPE_BITSTRING:  /* library type */
    case BASICTYPE_ENUMERATED:  /* library type */
    case BASICTYPE_NUMERIC_STR:  /* 22 */
    case BASICTYPE_PRINTABLE_STR: /* 23 */
    case BASICTYPE_UNIVERSAL_STR: /* 24 */
    case BASICTYPE_IA5_STR:      /* 25 */
    case BASICTYPE_BMP_STR:      /* 26 */
    case BASICTYPE_UTF8_STR:     /* 27 */
    case BASICTYPE_UTCTIME:      /* 28 tag 23 */
    case BASICTYPE_GENERALIZEDTIME: /* 29 tag 24 */
    case BASICTYPE_GRAPHIC_STR:     /* 30 tag 25 */
    case BASICTYPE_VISIBLE_STR:     /* 31 tag 26  aka ISO646String */
    case BASICTYPE_GENERAL_STR:     /* 32 tag 27 */
    case BASICTYPE_OBJECTDESCRIPTOR:	/* 33 tag 7 */
    case BASICTYPE_VIDEOTEX_STR:	/* 34 tag 21 */
    case BASICTYPE_T61_STR:			/* 35 tag 20 */
        PrintPySimpleDef(src, td);
        break;
    case BASICTYPE_SEQUENCEOF:  /* list types */
    case BASICTYPE_SETOF:
        PrintPySetOfDefCode(src, m, td, td->type);
        break;
    case BASICTYPE_IMPORTTYPEREF:  /* type references */
    case BASICTYPE_LOCALTYPEREF:
        /* if this type has been re-tagged then must create new class
         * instead of using a typedef */
        PrintPySimpleDef(src, td);
        break;
    case BASICTYPE_CHOICE:
        PrintPyChoiceDefCode(src, hdr, mods, m, r, td, NULL, td->type, novolatilefuncs);
        break;
    case BASICTYPE_SET:
        PrintPySetDefCode(src, hdr, mods, m, r, td, NULL, td->type, novolatilefuncs);
        break;
    case BASICTYPE_SEQUENCE:
        PrintPySeqDefCode(src, hdr, mods, m, r, td, NULL, td->type, novolatilefuncs);
        break;
    case BASICTYPE_COMPONENTSOF:
    case BASICTYPE_SELECTION:
    case BASICTYPE_UNKNOWN:
    case BASICTYPE_MACRODEF:
    case BASICTYPE_MACROTYPE:
    case BASICTYPE_ANYDEFINEDBY:  /* ANY types */
    case BASICTYPE_ANY:
        /* do nothing */
        break;
    default:
        /* TBD: print error? */
        break;
    }
} /* PrintPyTypeDefCode */

void
PrintPyCode PARAMS ((src, hdr, if_META (printMeta COMMA meta COMMA meta_pdus COMMA)
					 mods, m, r, longJmpVal, printTypes, printValues,
					 printEncoders, printDecoders, printPrinters, printFree
					 if_TCL (COMMA printTcl), novolatilefuncs),
    FILE *src _AND_
    FILE *hdr _AND_
    if_META (MetaNameStyle printMeta _AND_)
    if_META (const Meta *meta _AND_)
    if_META (MetaPDU *meta_pdus _AND_)
    ModuleList *mods _AND_
    Module *m _AND_
    PyRules *r _AND_
    long longJmpVal ESNACC_UNUSED _AND_
    int printTypes _AND_
    int printValues _AND_
    int printEncoders _AND_
    int printDecoders _AND_
    int printPrinters _AND_
    int printFree
    if_TCL (_AND_ int printTcl) _AND_
    int novolatilefuncs)
{
	Module *currMod;
    AsnListNode *currModTmp;
    TypeDef *td;
    ValueDef *vd;


    printTypesG = printTypes;
    printEncodersG = printEncoders;
    printDecodersG = printDecoders;
    printPrintersG = printPrinters;
    printFreeG = printFree;

    PrintSrcComment(src, m);
    PrintSrcIncludes(src);

    FOR_EACH_LIST_ELMT (currMod, mods) {
		if (!strcmp(m->cxxHdrFileName, currMod->cxxHdrFileName)) {
            ImportModuleList *ModLists;
            ImportModule *impMod;
            char *ImpFile = NULL;
            ModLists = currMod->imports;
            currModTmp = mods->curr;
            FOR_EACH_LIST_ELMT(impMod, ModLists) {
                ImpFile = GetImportFileName(impMod->modId->name, mods);
                if (ImpFile != NULL)
                    fprintf(src, "import %s\n", ImpFile);
                if (impMod->moduleRef == NULL)
                    impMod->moduleRef = GetImportModuleRef(impMod->modId->name, mods);
            }
            mods->curr = currModTmp;
        }
    }
    fprintf(src, "\n");

    if (printValues) {
        fprintf(src, "# value defs\n\n");
        FOR_EACH_LIST_ELMT (vd, m->valueDefs) {
            /* PrintPyValueDef(src, r, vd); */
        }
        fprintf(src, "\n");
    }

    fprintf(src, "# class member definitions:\n\n");
    PrintPyAnyCode (src, hdr, r, mods, m);

    FOR_EACH_LIST_ELMT (td, m->typeDefs) {
        PrintPyTypeDefCode(src, hdr, mods, m, r, td, novolatilefuncs);
    }

} /* PrintPyCode */

static char *
LookupNamespace PARAMS ((t, mods),
    Type *t _AND_
    ModuleList *mods)
{
    char *pszNamespace = NULL;
    Module *mTmp = NULL;
    TypeDef *ptTmp = NULL;
    BasicType *pbtTmp2 = NULL;

    pbtTmp2 = t->basicType;
    if (pbtTmp2->choiceId == BASICTYPE_SEQUENCEOF ||
        pbtTmp2->choiceId == BASICTYPE_SETOF)
        pbtTmp2 = pbtTmp2->a.sequenceOf->basicType;  // Burrow 1 more layer down for SequenceOf/SetOf
    if (pbtTmp2->choiceId == BASICTYPE_IMPORTTYPEREF) {
        FOR_EACH_LIST_ELMT (mTmp, mods) {
            ptTmp = LookupType(mTmp->typeDefs,
                               pbtTmp2->a.importTypeRef->typeName); //WHAT we are looking for...
            if (ptTmp != NULL)
                break;      //FOUND the MODULE that contains our defninition...
        }

        if (ptTmp != NULL && mTmp != NULL && mTmp->namespaceToUse) {
            pszNamespace = mTmp->namespaceToUse;
        }
    }

    return(pszNamespace);
}
